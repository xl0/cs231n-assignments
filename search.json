[
  {
    "objectID": "aknn_impl.html",
    "href": "aknn_impl.html",
    "title": "KNN implementaiton",
    "section": "",
    "text": "from builtins import range\nfrom builtins import object\nimport numpy as np\n\n\nclass KNearestNeighbor(object):\n    \"\"\" a kNN classifier with L2 distance \"\"\"\n\n    def __init__(self):\n        pass\n\n    def train(self, X, y):\n        \"\"\"\n        Train the classifier. For k-nearest neighbors this is just\n        memorizing the training data.\n\n        Inputs:\n        - X: A numpy array of shape (num_train, D) containing the training data\n          consisting of num_train samples each of dimension D.\n        - y: A numpy array of shape (N,) containing the training labels, where\n             y[i] is the label for X[i].\n        \"\"\"\n        self.X_train = X\n        self.y_train = y\n\n    def predict(self, X, k=1, num_loops=0):\n        \"\"\"\n        Predict labels for test data using this classifier.\n\n        Inputs:\n        - X: A numpy array of shape (num_test, D) containing test data consisting\n             of num_test samples each of dimension D.\n        - k: The number of nearest neighbors that vote for the predicted labels.\n        - num_loops: Determines which implementation to use to compute distances\n          between training points and testing points.\n\n        Returns:\n        - y: A numpy array of shape (num_test,) containing predicted labels for the\n          test data, where y[i] is the predicted label for the test point X[i].\n        \"\"\"\n        if num_loops == 0:\n            dists = self.compute_distances_no_loops(X)\n        elif num_loops == 1:\n            dists = self.compute_distances_one_loop(X)\n        elif num_loops == 2:\n            dists = self.compute_distances_two_loops(X)\n        else:\n            raise ValueError(\"Invalid value %d for num_loops\" % num_loops)\n\n        return self.predict_labels(dists, k=k)\n\n    def compute_distances_two_loops(self, X):\n        \"\"\"\n        Compute the distance between each test point in X and each training point\n        in self.X_train using a nested loop over both the training data and the\n        test data.\n\n        Inputs:\n        - X: A numpy array of shape (num_test, D) containing test data.\n\n        Returns:\n        - dists: A numpy array of shape (num_test, num_train) where dists[i, j]\n          is the Euclidean distance between the ith test point and the jth training\n          point.\n        \"\"\"\n        num_test = X.shape[0]\n        num_train = self.X_train.shape[0]\n        dists = np.zeros((num_test, num_train))\n        for i in range(num_test):\n            for j in range(num_train):\n                #####################################################################\n                # TODO:                                                             #\n                # Compute the l2 distance between the ith test point and the jth    #\n                # training point, and store the result in dists[i, j]. You should   #\n                # not use a loop over dimension, nor use np.linalg.norm().          #\n                #####################################################################\n                # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n\n                dists[i, j] = np.sqrt( ((self.X_train[j] - X[i])**2).sum() )\n            \n                # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n        return dists\n\n    def compute_distances_one_loop(self, X):\n        \"\"\"\n        Compute the distance between each test point in X and each training point\n        in self.X_train using a single loop over the test data.\n\n        Input / Output: Same as compute_distances_two_loops\n        \"\"\"\n        num_test = X.shape[0]\n        num_train = self.X_train.shape[0]\n        dists = np.zeros((num_test, num_train))\n        for i in range(num_test):\n            #######################################################################\n            # TODO:                                                               #\n            # Compute the l2 distance between the ith test point and all training #\n            # points, and store the result in dists[i, :].                        #\n            # Do not use np.linalg.norm().                                        #\n            #######################################################################\n            # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n\n            dists[i, :] = np.sqrt(((self.X_train - X[i]) ** 2).sum(axis=1))\n            # dists[i] = np.sqrt(np.power())\n\n            # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n        return dists\n\n    def compute_distances_no_loops(self, X):\n        \"\"\"\n        Compute the distance between each test point in X and each training point\n        in self.X_train using no explicit loops.\n\n        Input / Output: Same as compute_distances_two_loops\n        \"\"\"\n        num_test = X.shape[0]\n        num_train = self.X_train.shape[0]\n        dists = np.zeros((num_test, num_train))\n        #########################################################################\n        # TODO:                                                                 #\n        # Compute the l2 distance between all test points and all training      #\n        # points without using any explicit loops, and store the result in      #\n        # dists.                                                                #\n        #                                                                       #\n        # You should implement this function using only basic array operations; #\n        # in particular you should not use functions from scipy,                #\n        # nor use np.linalg.norm().                                             #\n        #                                                                       #\n        # HINT: Try to formulate the l2 distance using matrix multiplication    #\n        #       and two broadcast sums.                                         #\n        #########################################################################\n        # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n\n        # Not gonna lie, I had to look it up\n        dists = np.sqrt((   -2 * np.dot(X, self.X_train.T) +\n                            np.sum(self.X_train**2, axis=1) +\n                            np.sum(X**2,            axis=1)[:, None] ))\n\n\n\n        # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n        return dists\n\n    def predict_labels(self, dists, k=1):\n        \"\"\"\n        Given a matrix of distances between test points and training points,\n        predict a label for each test point.\n\n        Inputs:\n        - dists: A numpy array of shape (num_test, num_train) where dists[i, j]\n          gives the distance betwen the ith test point and the jth training point.\n\n        Returns:\n        - y: A numpy array of shape (num_test,) containing predicted labels for the\n          test data, where y[i] is the predicted label for the test point X[i].\n        \"\"\"\n        num_test = dists.shape[0]\n        y_pred = np.zeros(num_test)\n        for i in range(num_test):\n            # A list of length k storing the labels of the k nearest neighbors to\n            # the ith test point.\n            closest_y = []\n            #########################################################################\n            # TODO:                                                                 #\n            # Use the distance matrix to find the k nearest neighbors of the ith    #\n            # testing point, and use self.y_train to find the labels of these       #\n            # neighbors. Store these   in closest_y.                           #\n            # Hint: Look up the function numpy.argsort.                             #\n            #########################################################################\n            # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n\n            closest_idxs = np.argsort(dists[i])[:k]\n            closest_y = self.y_train[closest_idxs]\n\n            # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n            #########################################################################\n            # TODO:                                                                 #\n            # Now that you have found the labels of the k nearest neighbors, you    #\n            # need to find the most common label in the list closest_y of labels.   #\n            # Store this label in y_pred[i]. Break ties by choosing the smaller     #\n            # label.                                                                #\n            #########################################################################\n            # *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n\n            unique, counts = np.unique(closest_y, return_counts=True)\n            uc = list(zip(unique, counts))\n            uc.sort(key=lambda uc: uc[0] + (uc[1]+1) *10)\n\n            y_pred[i]=uc[-1][0]\n\n            # *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n\n        return y_pred\n\n\n\nKNearestNeighbor\n\n KNearestNeighbor ()\n\na kNN classifier with L2 distance"
  },
  {
    "objectID": "aknn.html",
    "href": "aknn.html",
    "title": "k-Nearest Neighbor (kNN) exercise",
    "section": "",
    "text": "Complete and hand in this completed worksheet (including its outputs and any supporting code outside of the worksheet) with your assignment submission. For more details see the assignments page on the course website.\nThe kNN classifier consists of two stages:\n\nDuring training, the classifier takes the training data and simply remembers it\nDuring testing, kNN classifies every test image by comparing to all training images and transfering the labels of the k most similar training examples\nThe value of k is cross-validated\n\nIn this exercise you will implement these steps and understand the basic Image Classification pipeline, cross-validation, and gain proficiency in writing efficient, vectorized code.\n\n# Run some setup code for this notebook.\n\nimport random\nimport numpy as np\nfrom cs231n.data_utils import load_CIFAR10\nimport matplotlib.pyplot as plt\nfrom lovely_numpy import lo, config\n\n\n# This is a bit of magic to make matplotlib figures appear inline in the notebook\n# rather than in a new window.\n\nplt.rcParams['figure.figsize'] = (10.0, 8.0) # set default size of plots\nplt.rcParams['image.interpolation'] = 'nearest'\nplt.rcParams['image.cmap'] = 'gray'\n\n# Some more magic so that the notebook will reload external python modules;\n# see http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython\n\n\n# Load the raw CIFAR-10 data.\ncifar10_dir = 'cs231n/datasets/cifar-10-batches-py'\n\n# Cleaning up variables to prevent loading data multiple times (which may cause memory issue)\n# try:\n#    del X_train, y_train\n#    del X_test, y_test\n#    print('Clear previously loaded data.')\n# except:\n#    pass\n\nX_train, y_train, X_test, y_test = load_CIFAR10(cifar10_dir)\n\n# As a sanity check, we print out the size of the training and test data.\nprint('Training data shape: ', lo(X_train))\nprint('Training labels shape: ', lo(y_train))\nprint('Test data shape: ', lo(X_test))\nprint('Test labels shape: ', lo(y_test))\n\nTraining data shape:  array[50000, 32, 32, 3] n=153600000 x∈[0., 255.000] μ=120.708 σ=64.150\nTraining labels shape:  array[50000] i64 x∈[0, 9] μ=4.500 σ=2.872\nTest data shape:  array[10000, 32, 32, 3] n=30720000 x∈[0., 255.000] μ=121.529 σ=64.061\nTest labels shape:  array[10000] i64 x∈[0, 9] μ=4.500 σ=2.872\n\n\n\n# Visualize some examples from the dataset.\n# We show a few examples of training images from each class.\nclasses = ['plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck']\nnum_classes = len(classes)\nsamples_per_class = 7\nfor y, cls in enumerate(classes):\n    idxs = np.flatnonzero(y_train == y)\n    idxs = np.random.choice(idxs, samples_per_class, replace=False)\n    for i, idx in enumerate(idxs):\n        plt_idx = i * num_classes + y + 1\n        plt.subplot(samples_per_class, num_classes, plt_idx)\n        plt.imshow(X_train[idx].astype('uint8'))\n        plt.axis('off')\n        if i == 0:\n            plt.title(cls)\nplt.show()\n\n\n\n\n\n# Subsample the data for more efficient code execution in this exercise\nnum_training = 5000\nmask = list(range(num_training))\nX_train = X_train[mask]\ny_train = y_train[mask]\n\nnum_test = 500\nmask = list(range(num_test))\nX_test = X_test[mask]\ny_test = y_test[mask]\n\n# Reshape the image data into rows\nX_train = np.reshape(X_train, (X_train.shape[0], -1))\nX_test = np.reshape(X_test, (X_test.shape[0], -1))\nprint(f\"{lo(X_train)=}\")\nprint(f\" {lo(X_test)=}\")\n\nlo(X_train)=array[5000, 3072] n=15360000 x∈[0., 255.000] μ=120.457 σ=64.399\n lo(X_test)=array[500, 3072] n=1536000 x∈[0., 255.000] μ=123.493 σ=64.826\n\n\n\nfrom lib.knn_impl import KNearestNeighbor\n\n\n# from cs231n.classifiers import KNearestNeighbor\n\n# Create a kNN classifier instance.\n# Remember that training a kNN classifier is a noop: \n# the Classifier simply remembers the data and does no further processing \nclassifier = KNearestNeighbor()\nclassifier.train(X_train, y_train)\n\nWe would now like to classify the test data with the kNN classifier. Recall that we can break down this process into two steps:\n\nFirst we must compute the distances between all test examples and all train examples.\nGiven these distances, for each test example we find the k nearest examples and have them vote for the label\n\nLets begin with computing the distance matrix between all training and test examples. For example, if there are Ntr training examples and Nte test examples, this stage should result in a Nte x Ntr matrix where each element (i,j) is the distance between the i-th test and j-th train example.\nNote: For the three distance computations that we require you to implement in this notebook, you may not use the np.linalg.norm() function that numpy provides.\nFirst, open cs231n/classifiers/k_nearest_neighbor.py and implement the function compute_distances_two_loops that uses a (very inefficient) double loop over all pairs of (test, train) examples and computes the distance matrix one element at a time.\n\n# Open cs231n/classifiers/k_nearest_neighbor.py and implement\n# compute_distances_two_loops.\n\n# Test your implementation:\ndists = classifier.compute_distances_two_loops(X_test)\nprint(lo(dists))\n\narray[500, 5000] n=2500000 x∈[1.066e+03, 1.231e+04] μ=4.861e+03 σ=1.173e+03\n\n\n\n# We can visualize the distance matrix: each row is a single test example and\n# its distances to training examples\nplt.imshow(dists, interpolation='none')\nplt.show()\n\n\n\n\nInline Question 1\nNotice the structured patterns in the distance matrix, where some rows or columns are visibly brighter. (Note that with the default color scheme black indicates low distances while white indicates high distances.)\n\nWhat in the data is the cause behind the distinctly bright rows?\nWhat causes the columns?\n\n\\(\\color{blue}{\\textit Your Answer:}\\) fill this in.\nIn both cases (test, train), the dark stripes correspond to examples that have “mild” pixel intensities, and the bright ones have pixels with either very high or very low intensities.\nLet’s test this idea:\n\ntest_intensities = np.argsort(dists.sum(axis=1))\n\ntest_top_5 = test_intensities[-5:]\ntest_bot_5 = test_intensities[:5]\n\n\ntrain_intensities = np.argsort(dists.sum(axis=0))\n\ntrain_top_5 = train_intensities[-5:]\ntrain_bot_5 = train_intensities[:5]\n\n\nfor i in range(5):\n    plt.subplot(5,4, 4*i + 1)\n    plt.imshow(X_test[test_top_5[i]].reshape(32,32,3).astype(\"uint8\"))\n    plt.axis(False)\n    if not i:\n        plt.title(\"Top 5 test\")\n\n    plt.subplot(5,4, 4*i+2)\n    plt.imshow(X_test[test_bot_5[i]].reshape(32,32,3).astype(\"uint8\"))\n    plt.axis(False)\n    if not i:\n        plt.title(\"Bot 5 test\")\n\n    plt.subplot(5,4, 4*i + 3)\n    plt.imshow(X_train[train_top_5[i]].reshape(32,32,3).astype(\"uint8\"))\n    plt.axis(False)\n    if not i:\n        plt.title(\"Top 5 train\")\n\n    plt.subplot(5,4, 4*i+4)\n    plt.imshow(X_train[train_bot_5[i]].reshape(32,32,3).astype(\"uint8\"))\n    plt.axis(False)\n    if not i:\n        plt.title(\"Bot 5 test\")\n\n\n\n\nLooks like I was correct\n\n# Now implement the function predict_labels and run the code below:\n# We use k = 1 (which is Nearest Neighbor).\ny_test_pred = classifier.predict_labels(dists, k=1)\n\n# Compute and print the fraction of correctly predicted examples\nnum_correct = np.sum(y_test_pred == y_test)\naccuracy = float(num_correct) / num_test\nprint('Got %d / %d correct => accuracy: %f' % (num_correct, num_test, accuracy))\n\nGot 137 / 500 correct => accuracy: 0.274000\n\n\nYou should expect to see approximately 27% accuracy. Now lets try out a larger k, say k = 5:\n\ny_test_pred = classifier.predict_labels(dists, k=5)\nnum_correct = np.sum(y_test_pred == y_test)\naccuracy = float(num_correct) / num_test\nprint('Got %d / %d correct => accuracy: %f' % (num_correct, num_test, accuracy))\n\nGot 143 / 500 correct => accuracy: 0.286000\n\n\nYou should expect to see a slightly better performance than with k = 1.\nInline Question 2\nWe can also use other distance metrics such as L1 distance. For pixel values \\(p_{ij}^{(k)}\\) at location \\((i,j)\\) of some image \\(I_k\\),\nthe mean \\(\\mu\\) across all pixels over all images is \\[\\mu=\\frac{1}{nhw}\\sum_{k=1}^n\\sum_{i=1}^{h}\\sum_{j=1}^{w}p_{ij}^{(k)}\\] And the pixel-wise mean \\(\\mu_{ij}\\) across all images is \\[\\mu_{ij}=\\frac{1}{n}\\sum_{k=1}^np_{ij}^{(k)}.\\] The general standard deviation \\(\\sigma\\) and pixel-wise standard deviation \\(\\sigma_{ij}\\) is defined similarly.\nWhich of the following preprocessing steps will not change the performance of a Nearest Neighbor classifier that uses L1 distance? Select all that apply. 1. Subtracting the mean \\(\\mu\\) (\\(\\tilde{p}_{ij}^{(k)}=p_{ij}^{(k)}-\\mu\\).) 2. Subtracting the per pixel mean \\(\\mu_{ij}\\) (\\(\\tilde{p}_{ij}^{(k)}=p_{ij}^{(k)}-\\mu_{ij}\\).) 3. Subtracting the mean \\(\\mu\\) and dividing by the standard deviation \\(\\sigma\\). 4. Subtracting the pixel-wise mean \\(\\mu_{ij}\\) and dividing by the pixel-wise standard deviation \\(\\sigma_{ij}\\). 5. Rotating the coordinate axes of the data.\n\\(\\color{blue}{\\textit Your Answer:}\\) 1. [v] Substracting mean will not change the difference matrix, as the mean will be substracted from both sides when calculating per-pixel difference.\n\n[v] Substracting per-pixel mean also does not change the difference matrix, as for each pixel pair, the same mean values will be substracted from both sides.\n[v] Substracting mean and dividing by std will result in a difference matrix (that is scaled down by 1/std), but since all distances will be scaled by the same amount, the predicted labels will remain the same.\nThe predicitons will change. After dividing each pixel by pixel-wise std, the influence this particular pixel has on the prediciton will be scaled down by 1/std.\nWhat do you mean by “Rotating the coordinate axes of the data.”? Swap h and w? This will not affect the result.\n\n\\(\\color{blue}{\\textit Your Explanation:}\\)\n\n# Now lets speed up distance matrix computation by using partial vectorization\n# with one loop. Implement the function compute_distances_one_loop and run the\n# code below:\ndists_one = classifier.compute_distances_one_loop(X_test)\n\n# To ensure that our vectorized implementation is correct, we make sure that it\n# agrees with the naive implementation. There are many ways to decide whether\n# two matrices are similar; one of the simplest is the Frobenius norm. In case\n# you haven't seen it before, the Frobenius norm of two matrices is the square\n# root of the squared sum of differences of all elements; in other words, reshape\n# the matrices into vectors and compute the Euclidean distance between them.\ndifference = np.linalg.norm(dists - dists_one, ord='fro')\nprint('One loop difference was: %f' % (difference, ))\nif difference < 0.001:\n    print('Good! The distance matrices are the same')\nelse:\n    print('Uh-oh! The distance matrices are different')\n\nOne loop difference was: 0.000000\nGood! The distance matrices are the same\n\n\n\n# Now implement the fully vectorized version inside compute_distances_no_loops\n# and run the code\ndists_two = classifier.compute_distances_no_loops(X_test)\n\n# (x-y)^2 = x^2 + y^2 - 2xy\n\n# dists_two = np.sqrt(((X_test[:,None,:] - classifier.X_train)**2).sum(axis=-1))\n\n# check that the distance matrix agrees with the one we computed before:\ndifference = np.linalg.norm(dists - dists_two, ord='fro')\nprint('No loop difference was: %f' % (difference, ))\nif difference < 0.001:\n    print('Good! The distance matrices are the same')\nelse:\n    print('Uh-oh! The distance matrices are different')\n\nNo loop difference was: 0.000000\nGood! The distance matrices are the same\n\n\n\n# Let's compare how fast the implementations are\ndef time_function(f, *args):\n    \"\"\"\n    Call a function f with args and return the time (in seconds) that it took to execute.\n    \"\"\"\n    import time\n    tic = time.time()\n    f(*args)\n    toc = time.time()\n    return toc - tic\n\ntwo_loop_time = time_function(classifier.compute_distances_two_loops, X_test)\nprint('Two loop version took %f seconds' % two_loop_time)\n\none_loop_time = time_function(classifier.compute_distances_one_loop, X_test)\nprint('One loop version took %f seconds' % one_loop_time)\n\nno_loop_time = time_function(classifier.compute_distances_no_loops, X_test)\nprint('No loop version took %f seconds' % no_loop_time)\n\n# You should see significantly faster performance with the fully vectorized implementation!\n\n# NOTE: depending on what machine you're using, \n# you might not see a speedup when you go from two loops to one loop, \n# and might even see a slow-down.\n\nTwo loop version took 16.607513 seconds\nOne loop version took 16.501603 seconds\nNo loop version took 0.089059 seconds\n\n\n\nCross-validation\nWe have implemented the k-Nearest Neighbor classifier but we set the value k = 5 arbitrarily. We will now determine the best value of this hyperparameter with cross-validation.\n\na = [1,2,3,4,5]\nn = 2\na[:n] + a[n+1:]\n\n[1, 2, 4, 5]\n\n\n\nnum_folds = 5\nk_choices = [1, 3, 5, 8, 10, 12, 15, 20, 50, 100]\n\nX_train_folds = []\ny_train_folds = []\n################################################################################\n# TODO:                                                                        #\n# Split up the training data into folds. After splitting, X_train_folds and    #\n# y_train_folds should each be lists of length num_folds, where                #\n# y_train_folds[i] is the label vector for the points in X_train_folds[i].     #\n# Hint: Look up the numpy array_split function.                                #\n################################################################################\n# *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n\nX_train_folds = np.array_split(X_train, num_folds)\ny_train_folds = np.array_split(y_train, num_folds)\n\n\n# *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n\n# A dictionary holding the accuracies for different values of k that we find\n# when running cross-validation. After running cross-validation,\n# k_to_accuracies[k] should be a list of length num_folds giving the different\n# accuracy values that we found when using that value of k.\nk_to_accuracies = {}\n\n################################################################################\n# TODO:                                                                        #\n# Perform k-fold cross validation to find the best value of k. For each        #\n# possible value of k, run the k-nearest-neighbor algorithm num_folds times,   #\n# where in each case you use all but one of the folds as training data and the #\n# last fold as a validation set. Store the accuracies for all fold and all     #\n# values of k in the k_to_accuracies dictionary.                               #\n################################################################################\n# *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n\nfor k in k_choices:\n    k_to_accuracies[k] = []\n\nfor fold in range(num_folds):\n        classifier.train(np.concatenate(X_train_folds[:fold] + X_train_folds[fold+1:]),\n                         np.concatenate(y_train_folds[:fold] + y_train_folds[fold+1:]))\n        \n        for k in k_choices:\n            preds = classifier.predict(X_train_folds[fold], k=k)\n            accuracy = np.sum(preds == y_train_folds[fold]).astype(float) / len(y_train_folds[fold])\n            k_to_accuracies[k].append(accuracy)\n\n# *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n\n\n# Print out the computed accuracies\nfor k in sorted(k_to_accuracies):\n    mean = sum(k_to_accuracies[k]) / len(k_to_accuracies[k])\n    print(f'k = {k}, accuracy = {mean:.4f} : {k_to_accuracies[k]}')\n\nk = 1, accuracy = 0.2656 : [0.263, 0.257, 0.264, 0.278, 0.266]\nk = 3, accuracy = 0.2740 : [0.252, 0.281, 0.266, 0.29, 0.281]\nk = 5, accuracy = 0.2856 : [0.266, 0.285, 0.29, 0.303, 0.284]\nk = 8, accuracy = 0.2884 : [0.27, 0.31, 0.281, 0.29, 0.291]\nk = 10, accuracy = 0.2894 : [0.276, 0.298, 0.296, 0.289, 0.288]\nk = 12, accuracy = 0.2834 : [0.268, 0.302, 0.287, 0.28, 0.28]\nk = 15, accuracy = 0.2872 : [0.269, 0.299, 0.294, 0.291, 0.283]\nk = 20, accuracy = 0.2820 : [0.265, 0.291, 0.29, 0.282, 0.282]\nk = 50, accuracy = 0.2752 : [0.274, 0.289, 0.276, 0.264, 0.273]\nk = 100, accuracy = 0.2656 : [0.265, 0.274, 0.265, 0.259, 0.265]\n\n\n\n# plot the raw observations\nfor k in k_choices:\n    accuracies = k_to_accuracies[k]\n    plt.scatter([k] * len(accuracies), accuracies)\n\n# plot the trend line with error bars that correspond to standard deviation\naccuracies_mean = np.array([np.mean(v) for k,v in sorted(k_to_accuracies.items())])\naccuracies_std = np.array([np.std(v) for k,v in sorted(k_to_accuracies.items())])\nplt.errorbar(k_choices, accuracies_mean, yerr=accuracies_std)\nplt.title('Cross-validation on k')\nplt.xlabel('k')\nplt.ylabel('Cross-validation accuracy')\nplt.show()\n\n\n\n\n\n# Based on the cross-validation results above, choose the best value for k,   \n# retrain the classifier using all the training data, and test it on the test\n# data. You should be able to get above 28% accuracy on the test data.\nbest_k = 5\n\nclassifier = KNearestNeighbor()\nclassifier.train(X_train, y_train)\ny_test_pred = classifier.predict(X_test, k=best_k)\n\n# Compute and display the accuracy\nnum_correct = np.sum(y_test_pred == y_test)\naccuracy = float(num_correct) / num_test\nprint('Got %d / %d correct => accuracy: %f' % (num_correct, num_test, accuracy))\n\nGot 143 / 500 correct => accuracy: 0.286000\n\n\nInline Question 3\nWhich of the following statements about \\(k\\)-Nearest Neighbor (\\(k\\)-NN) are true in a classification setting, and for all \\(k\\)? Select all that apply.\n\nThe decision boundary of the k-NN classifier is linear.\nThe training error of a 1-NN will always be lower than or equal to that of 5-NN.\nThe test error of a 1-NN will always be lower than that of a 5-NN.\nThe time needed to classify a test example with the k-NN classifier grows with the size of the training set.\nNone of the above.\n\n\\(\\color{blue}{\\textit Your Answer:}\\)\n\nNo, it’s not linear\nYes, for 1-NN the training erro will always be 0. For 5-NN examples that are overall closed to other class pixel-wise will have the wrong clas.\nIn practical terms, the test error will the lower for 5-NN, but it’s theoretically possible (although in practice inplausible) to have a test set that has outliers similar to the training set, and 1-NN might perform better on it.\nYes, as you need to calculate the distance between each test and training example.\n\n\\(\\color{blue}{\\textit Your Explanation:}\\)"
  }
]